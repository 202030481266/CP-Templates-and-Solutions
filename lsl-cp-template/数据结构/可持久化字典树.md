# 🚀 高效可持久化字典树 (Persistent Trie) 模板

这是一个专为算法竞赛（CP）和高性能场景设计的**可持久化字典树** C++ 模板。默认实现为 01-Trie，但可以通过修改常量轻松扩展为多路字典树（如 26 叉小写字母树）。

## ✨ 核心特性

* **极致性能**：纯数组实现，摒弃指针和动态内存分配，最大化缓存命中率（Cache Locality）。
* **极速初始化**：专为 Multi-test cases 设计的 `init()` 函数，时间复杂度仅为 $O(\text{SIGMA})$，完美避免 `memset` 导致的 TLE（超时）。
* **高度灵活**：常量配置区独立，`SIGMA`（字符集大小）和 `MAX_BITS`（最大位数）可按需修改，极易 Hack。
* **区间查询支持**：通过维护 `cnt`（子树大小）数组，利用前缀和思想完美支持区间 $[L, R]$ 的差分查询。

## 🧠 实现原理 (Core Mechanism)

可持久化数据结构的核心思想是**“复用”与“路径克隆”**。

当我们向字典树中插入一个新元素时，我们**不修改**原有的节点，而是为发生改变的路径（以及叶子节点）创建全新的节点。对于未发生改变的分支，新节点直接指向历史版本的旧节点。
同时，我们在每个节点维护一个 `cnt` 值，表示插入时经过该节点的元素个数。查询区间 $[L, R]$ 时，只需比较 `cnt[Root_R] - cnt[Root_{L-1}]`，若大于 0，说明在该区间内存在对应的分支。

## 🛠️ API 说明

| 方法 / 变量 | 说明 |
| --- | --- |
| `init()` | 初始化模板。在多组测试数据前调用，仅重置计数器和根节点，极速清空。 |
| `insert(p_root, val)` | 插入操作。基于旧版本根节点 `p_root` 插入 `val`，**返回新版本的根节点编号**。 |
| `query_max_xor(l_root, r_root, val)` | 区间查询。在版本 `l_root` 到 `r_root` 的增量中，查找与 `val` 异或结果**最大**的值。 |
| `query_min_xor(l_root, r_root, val)` | 区间查询。在版本 `l_root` 到 `r_root` 的增量中，查找与 `val` 异或结果**最小**的值。 |
| `root[i]` | 数组，用于保存第 `i` 次操作（或第 `i` 个元素）生成的新根节点编号。 |

---

## 💻 快速开始 (Quick Start & Example)

以下是一个完整的可编译运行示例。
**题目背景**：给定一个长度为 `N` 的数组 `A`，有 `Q` 次询问。每次询问给定 `L, R, X`，要求在数组区间 `[L, R]` 中找出一个数 `A[i]`，使得 `A[i] ^ X` 的值最大，并输出这个最大异或值。

```cpp
#include <iostream>
#include <vector>

using namespace std;

// ---------------- 粘贴上面的 PersistentTrie 模板代码 ----------------
const int MAX_VERSIONS = 200005; 
const int MAX_BITS = 30;         
const int SIGMA = 2;             
const int MAX_NODES = MAX_VERSIONS * (MAX_BITS + 2); 

struct PersistentTrie {
    int ch[MAX_NODES][SIGMA]; 
    int cnt[MAX_NODES];       
    int root[MAX_VERSIONS];   
    int tot;                  

    void init() {
        tot = 0;
        cnt[0] = 0;
        for (int i = 0; i < SIGMA; ++i) ch[0][i] = 0;
        root[0] = 0;
    }

    int clone(int p) {
        int q = ++tot;
        cnt[q] = cnt[p] + 1; 
        for (int i = 0; i < SIGMA; ++i) ch[q][i] = ch[p][i];
        return q;
    }

    int insert(int p_root, int val) {
        int q_root = clone(p_root);
        int curr = q_root, p = p_root;
        for (int i = MAX_BITS - 1; i >= 0; --i) {
            int c = (val >> i) & 1; 
            ch[curr][c] = clone(ch[p][c]); 
            curr = ch[curr][c];
            p = ch[p][c];
        }
        return q_root;
    }

    int query_max_xor(int l_root, r_root, int val) {
        int res = 0;
        int p = l_root, q = r_root;
        for (int i = MAX_BITS - 1; i >= 0; --i) {
            int c = (val >> i) & 1;
            int best = c ^ 1; 
            if (cnt[ch[q][best]] - cnt[ch[p][best]] > 0) {
                res |= (1 << i);
                q = ch[q][best];
                p = ch[p][best];
            } else {
                q = ch[q][c];
                p = ch[p][c];
            }
        }
        return res;
    }
} ptrie;
// -------------------------------------------------------------------

int main() {
    // 优化输入输出
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, q;
    // 假设输入格式: N Q
    // 接下来一行 N 个整数表示数组 A
    // 接下来 Q 行，每行三个整数 L R X (1-based)
    if (!(cin >> n >> q)) return 0;

    ptrie.init(); // 初始化模板

    for (int i = 1; i <= n; ++i) {
        int val;
        cin >> val;
        // 核心：第 i 个版本从第 i-1 个版本继承而来
        ptrie.root[i] = ptrie.insert(ptrie.root[i - 1], val);
    }

    while (q--) {
        int l, r, x;
        cin >> l >> r >> x;
        // 查询区间 [l, r]，传入版本 l-1 和 r 的根节点
        int ans = ptrie.query_max_xor(ptrie.root[l - 1], ptrie.root[r], x);
        cout << ans << "\n";
    }

    return 0;
}

```