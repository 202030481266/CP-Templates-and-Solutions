# CHT (Convex Hull Trick) 通用模板使用手册

## 1\. 适用场景

该数据结构主要用于优化如下形式的动态规划转移方程（斜率优化 DP）：
$$DP[i] = \min_{j < i} \{ DP[j] + A[i] \times B[j] + C[i] \}$$
也就是形如 $y = kx + b$ 的直线集合维护问题，目的是在 $O(1)$ 或 $O(\log N)$ 时间内求出给定 $x$ 下的全局最值。

## 2\. 核心代码模板

这是基于 `std::vector` 的通用实现。

```cpp
struct CHT {
    vector<ll> m, b; // m: 斜率, b: 截距
    int ptr = 0;     // 游标，用于线性查询优化

    // --- 【配置区域】 ---
    // 判断直线 l2 是否“无用”（即被 l1 和 l3 挡住）
    bool bad(int l1, int l2, int l3) {
        // 这里的公式实际上是比较交点：Intersect(l1, l2) vs Intersect(l2, l3)
        // 务必根据求 最大值 还是 最小值 选择正确的一行！
        
        // 模式 A: (斜率递减 && 求最小值) 或者 (斜率递增 && 求最大值)
        // return 1.0 * (b[l3] - b[l1]) * (m[l1] - m[l2]) <= 1.0 * (b[l2] - b[l1]) * (m[l1] - m[l3]);

        // 模式 B: (斜率递减 && 求最大值) 或者 (斜率递增 && 求最小值) 【当前你的需求】
        return 1.0 * (b[l3] - b[l1]) * (m[l1] - m[l2]) > 1.0 * (b[l2] - b[l1]) * (m[l1] - m[l3]);
    }

    // --- 【添加直线】 ---
    // 注意：加入的斜率 m 必须是单调的（递增或递减）
    void add(ll _m, ll _b) {
        m.push_back(_m);
        b.push_back(_b);
        int s = m.size();
        // 检查倒数第二条直线是否废弃
        while(s >= 3 && bad(s - 3, s - 2, s - 1)) {
            s--;
            m.erase(m.end() - 2); // 移除倒数第二个元素
            b.erase(b.end() - 2);
        }
    }

    // --- 【求值函数】 ---
    ll f(int i, ll x) { return m[i] * x + b[i]; }

    // --- 【查询 API 1：线性查询】 ---
    // 适用条件：查询的 x 也是单调的
    ll query(ll x) {
        if (ptr >= m.size()) ptr = m.size() - 1;
        // 如果 x 递增：用 ptr+1 vs ptr (找右边是否更优)
        // 如果 x 递减：逻辑可能需要反转（或在外部传入 -x）
        while (ptr < m.size() - 1 && f(ptr + 1, x) < f(ptr, x)) ptr++; // 注意：求最大值时改成 >
        return f(ptr, x);
    }

    // --- 【查询 API 2：二分查询】 ---
    // 适用条件：查询的 x 是无序的
    ll bs(int l, int r, ll x) {
        int mid = (l + r) / 2;
        // 下凸包（Min）找谷底：左高右低往右走，左低右高往左走
        if (mid + 1 < m.size() && f(mid + 1, x) < f(mid, x)) return bs(mid + 1, r, x); // 求最大值改成 >
        if (mid - 1 >= 0 && f(mid - 1, x) < f(mid, x)) return bs(l, mid - 1, x);       // 求最大值改成 >
        return f(mid, x);
    }
};
```

-----

## 3\. 配置指南 (Configuration Guide)

这是最容易出错的地方，请根据题目要求查表选择 `bad` 函数的写法。

### 第一步：确定目标

  * **Min**: 维护下凸包（形如碗底 $\cup$）。
  * **Max**: 维护上凸包（形如山峰 $\cap$）。

### 第二步：确定插入顺序

观察 DP 转移方程中 $k$ 的变化趋势。

  * **Inc**: 斜率 $k$ 随 $i$ 增大而增大。
  * **Dec**: 斜率 $k$ 随 $i$ 增大而减小。

### 第三步：查表选择 `bad` 函数

| 场景 | 斜率 ($m$) | 目标 (Min/Max) | 应该保留的代码行 | 符号 |
| :--- | :--- | :--- | :--- | :--- |
| **1** | 递减 $\downarrow$ | Min | 第一行 | `<=` |
| **2** | 递增 $\uparrow$ | Max | 第一行 | `<=` |
| **3** | 递减 $\downarrow$ | Max | 第二行 | `>` |
| **4** | **递增 $\uparrow$** | **Min (你的情况)** | **第二行** | **`>`** |

**判断逻辑记忆法：**

  * **异号用 `>=`**：斜率增减方向 和 凹凸方向（Min/Max）“逻辑相反”时。
  * **同号用 `>`**：斜率增减方向 和 凹凸方向 “逻辑相同”时（实际上很难硬记，**建议直接查表**）。

-----

## 4\. API 使用详解

### `void add(ll m, ll b)`

  * **前提**：必须保证调用 `add` 时，传入的 `m` 是严格单调的。如果不单调，必须使用平衡树（Li Chao Tree）而非此模板。
  * **细节**：如果新加入的直线斜率与最后一条完全相同（$m_{new} == m_{last}$），通常需要手动预判：
      * 求 Min：保留 $b$ 较小的。
      * 求 Max：保留 $b$ 较大的。
      * *注：原模板没写这个，如果题目数据有平行线，需在 push\_back 前加个 `if` 判断。*

### `ll query(ll x)` (线性查询)

  * **复杂度**：均摊 $O(1)$。
  * **前提**：查询的 $x$ 必须随着时间单调递增。
  * **原理**：因为 $x$ 变大，最优直线在凸包上只会向一个方向移动，不需要回头。
  * **修改**：如果你是求**最大值**，请将 `while` 循环中的 `<` 改为 `>`。

### `ll bs(int l, int r, ll x)` (二分查询)

  * **复杂度**：$O(\log N)$。
  * **前提**：$x$ 没有规律，忽大忽小。
  * **修改**：如果你是求**最大值**，请将两个 `if` 中的 `<` 都改为 `>`。

-----

## 5\. 常见坑点与解决方案

### 坑点 1：浮点数精度炸裂

代码中使用了 `1.0 * ...`，这是为了将 `long long` 转换为 `double` 防止乘法溢出。

  * **风险**：当坐标值超过 $10^{15}$ 时，`double` 的精度可能不足以区分两个交点的微小差异。
  * **解决**：使用 `__int128` 进行交叉相乘（推荐在所有竞赛中默认使用）。
    ```cpp
    // 推荐的 bad 函数写法 (替换 double)
    bool bad(int l1, int l2, int l3) {
        return (__int128)(b[l3] - b[l1]) * (m[l1] - m[l2]) > 
               (__int128)(b[l2] - b[l1]) * (m[l1] - m[l3]); 
    }
    ```

### 坑点 2：Query 越界

  * 代码中 `ptr` 只增不减。如果在多组测试数据（Multi-testcase）中，记得清空 `vector` 并重置 `ptr = 0`。

### 坑点 3：add 的单调性被打破

  * 如果你发现 $m$ 不是单调的，请立即停止使用此模板，转去学习 **李超线段树 (Li Chao Tree)**。

-----

## 6\. 快速检查清单 (Checklist)

在提交题目通过前，请检查：

1.  [ ] **斜率单调性**：我的输入 $m$ 是递增还是递减？
2.  [ ] **目标**：我是求 Min 还是 Max？
3.  [ ] **bad 函数**：符号是 `>` 还是 `<=`？（参考表格）
4.  [ ] **query 比较**：`query` 和 `bs` 里的比较符号是 `<` (求 Min) 还是 `>` (求 Max)？
5.  [ ] **精度**：数据范围是否超过 $10^{9}$？如果是，是否改用了 `__int128`？