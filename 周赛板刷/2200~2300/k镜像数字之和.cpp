// https://leetcode.cn/problems/sum-of-k-mirror-numbers/



// 速度还算可以但是过不了全部（卡常了），因为肯定存在数学规律，果断打表，一定可以
class Solution {
public:
	// 将x进制数字s转换成一个y进制 （进制k满足2<=k<=36）
	typedef long long ll;
	string transform(int x, int y, string s) {
		string res;
		ll sum = 0;
		for (int i = 0; i < s.length(); ++i) {
			if (s[i] == '-') continue;
			if (isdigit(s[i])) sum = sum * x + s[i] - '0';
			else sum = sum * x + s[i] - 'A' + 10;
		}
		while (sum) {
			char tmp = sum % y;
			sum /= y;
			if (tmp <= 9) tmp += '0';
			else tmp = tmp - 10 + 'A';
			res = tmp + res;
		}
		if (res.length() == 0) res = "0";
		if (s[0] == '-') res = '-' + res;
		return res;
	}
	string rev(string s) {
		string t = s;
		reverse(t.begin(), t.end());
		return t;
	}
	bool is_palidrom(string s) {
		int l = 0, r = s.size() - 1;
		while (l < r) if (s[l++] != s[r--]) return false;
		return true;
	}
	bool is_valid(int x, int y, string s) {
		string t = transform(x, y, s);
		if (t[0] == '0' || t.back() == '0' || s[0] == '0' || s.back() == '0') return false;
		return is_palidrom(s) && is_palidrom(t);
	}
    long long kMirror(int k, int n) {
        // 两种进制表达下都是回文串，应该会满足一些特别的性质
        // 由于回文数字本身不多，所以我觉得完全可以枚举所有的回文数字，然后判断即可
    	ll res = 0, ans = 0;
    	for (int len = 1; res < n; ++len) {
    		// 长度为len的回文数字
    		if (len & 1) {
    			// 12321，实际上任何长度为2的数字+一个数字
    			int tmp = (len - 1) / 2;
    			if (tmp > 0) {
	    			for (ll i = pow(10, tmp - 1); i < (ll)pow(10, tmp); ++i) { 
	    				for (int j = 0; j <= 9; ++j) {
	    					string num = to_string(i);
	    					string palid = num + to_string(j) + rev(num);
	    					if (is_valid(10, k, palid)) {
	    						++res;
	    						ans += stoll(palid);
	    						if (res == n) return ans;
	    					}
	    				}
	    			}
	    		} else {
	    			for (int i = 0; i <= 9; ++i) {
	    				if (is_valid(10, k, to_string(i))) {
	    					++res;
	    					ans += i;
	    					if (res == n) return ans;
	    				}
	    			}
	    		}
    		}
    		else {
    			// 1221，等于任何一个长度为一半的数字的反向拼接自己得到
    			int tmp = len / 2;
    			for (ll i = pow(10, tmp - 1); i < (ll)pow(10, tmp); ++i) {
    				string num = to_string(i);
    				string palid = num + rev(num);
    				if (is_valid(10, k, palid)) {
    					++res;
    					ans += stoll(palid);
    					if (res == n) return ans;
    				}
    			}
    		}
    	}
    	return ans;
    }
};


class Solution {
	static constexpr long long ans[8][30] = {{1,4,9,16,25,58,157,470,1055,1772,9219,18228,33579,65802,105795,159030,212865,286602,872187,2630758,4565149,6544940,9674153,14745858,20005383,25846868,39347399,759196316,1669569335,2609044274},
{1,3,7,15,136,287,499,741,1225,1881,2638,31730,80614,155261,230718,306985,399914,493653,1342501,2863752,5849644,9871848,14090972,18342496,22630320,28367695,36243482,44192979,71904751,155059889},
{1,3,6,11,66,439,832,1498,2285,3224,11221,64456,119711,175366,233041,739646,2540727,4755849,8582132,12448815,17500320,22726545,27986070,33283995,38898160,44577925,98400760,721411086,1676067545,53393239260},
{1,3,6,10,16,104,356,638,1264,1940,3161,18912,37793,10125794,20526195,48237967,78560270,126193944,192171900,1000828708,1832161846,2664029984,3500161622,4336343260,6849225412,9446112364,12339666346,19101218022,31215959143,43401017264},
{1,3,6,10,15,22,77,188,329,520,863,1297,2074,2942,4383,12050,19827,41849,81742,156389,325250,1134058,2043967,3911648,7009551,11241875,15507499,19806423,24322577,28888231},
{1,3,6,10,15,21,29,150,321,563,855,17416,83072,2220384,6822448,13420404,20379000,29849749,91104965,321578997,788407661,1273902245,1912731081,2570225837,3428700695,29128200347,69258903451,115121130305,176576075721,241030621167},
{1,3,6,10,15,21,28,37,158,450,783,1156,1570,2155,5818,14596,27727,41058,67520,94182,124285,154588,362290,991116,1651182,3148123,5083514,7054305,11253219,66619574},
{1,3,6,10,15,21,28,36,227,509,882,1346,1901,2547,3203,10089,35841,63313,105637,156242,782868,2323319,4036490,5757761,7586042,9463823,11349704,13750746,16185088,18627530}};
public:
    long long kMirror(int k, int n) {
        return ans[k - 2][n - 1];
    }
};